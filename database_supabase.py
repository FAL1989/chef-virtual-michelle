from typing import Dict, List, Optional, Union
import json
import logging
from datetime import datetime
from supabase import create_client, Client
import streamlit as st

# Configuração do logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class DatabaseError(Exception):
    """Exceção customizada para erros do banco de dados"""
    pass

class ReceitasDB:
    def __init__(self):
        """Inicializa a conexão com o Supabase"""
        try:
            url: str = st.secrets["SUPABASE_URL"]
            key: str = st.secrets["SUPABASE_KEY"]
            self.supabase: Client = create_client(url, key)
            logger.info("Conexão estabelecida com Supabase")
            self.criar_tabelas()
        except Exception as e:
            logger.error(f"Erro ao conectar ao Supabase: {e}")
            raise DatabaseError(f"Erro ao conectar ao Supabase: {e}")

    def criar_tabelas(self):
        """
        Verifica se as tabelas existem.
        No Supabase, as tabelas devem ser criadas manualmente ou via migrations.
        Este método serve apenas para documentação da estrutura.
        """
        """
        Estrutura das tabelas no Supabase:

        -- Tabela de receitas
        create table receitas (
            id bigint generated by default as identity primary key,
            titulo text not null,
            descricao text,
            utensilios text,
            ingredientes text,
            modo_preparo text,
            tempo_preparo text,
            porcoes integer,
            dificuldade text,
            harmonizacao text,
            calorias text,
            proteinas text,
            carboidratos text,
            gorduras text,
            fibras text,
            created_at timestamp with time zone default timezone('utc'::text, now()) not null,
            updated_at timestamp with time zone default timezone('utc'::text, now()) not null
        );

        -- Tabela de dicas
        create table dicas (
            id bigint generated by default as identity primary key,
            receita_id bigint references receitas(id),
            dica text not null,
            created_at timestamp with time zone default timezone('utc'::text, now()) not null
        );

        -- Tabela de benefícios funcionais
        create table beneficios_funcionais (
            id bigint generated by default as identity primary key,
            receita_id bigint references receitas(id),
            beneficio text not null,
            created_at timestamp with time zone default timezone('utc'::text, now()) not null
        );

        -- Trigger para atualizar updated_at
        create or replace function update_updated_at_column()
        returns trigger as $$
        begin
            new.updated_at = now();
            return new;
        end;
        $$ language plpgsql;

        create trigger update_receitas_updated_at
            before update on receitas
            for each row
            execute function update_updated_at_column();
        """
        pass

    def adicionar_receita(self, receita: Dict) -> bool:
        """Adiciona uma receita ao banco de dados"""
        try:
            # Prepara os dados da receita
            dados_receita = {
                'titulo': str(receita['titulo']),
                'descricao': str(receita.get('descricao', '')),
                'utensilios': str(receita.get('utensilios', '')),
                'ingredientes': '\n'.join(receita['ingredientes']) if isinstance(receita['ingredientes'], list) else str(receita['ingredientes']),
                'modo_preparo': '.\n'.join(receita['modo_preparo']) + '.' if isinstance(receita['modo_preparo'], list) else str(receita['modo_preparo']),
                'tempo_preparo': str(receita.get('tempo_preparo', '')),
                'porcoes': int(receita.get('porcoes', 0)),
                'dificuldade': str(receita.get('dificuldade', '')),
                'harmonizacao': str(receita.get('harmonizacao', '')),
            }

            # Adiciona informações nutricionais
            info_nutri = receita.get('informacoes_nutricionais', {})
            dados_receita.update({
                'calorias': str(info_nutri.get('calorias', '')),
                'proteinas': str(info_nutri.get('proteinas', '')),
                'carboidratos': str(info_nutri.get('carboidratos', '')),
                'gorduras': str(info_nutri.get('gorduras', '')),
                'fibras': str(info_nutri.get('fibras', ''))
            })

            # Insere a receita e obtém o ID
            result = self.supabase.table('receitas').insert(dados_receita).execute()
            receita_id = result.data[0]['id']

            # Adiciona dicas
            if 'dicas' in receita and receita['dicas']:
                dicas = receita['dicas'] if isinstance(receita['dicas'], list) else [receita['dicas']]
                for dica in dicas:
                    self.supabase.table('dicas').insert({
                        'receita_id': receita_id,
                        'dica': str(dica)
                    }).execute()

            # Adiciona benefícios funcionais
            if 'beneficios_funcionais' in receita and receita['beneficios_funcionais']:
                beneficios = receita['beneficios_funcionais'] if isinstance(receita['beneficios_funcionais'], list) else [receita['beneficios_funcionais']]
                for beneficio in beneficios:
                    self.supabase.table('beneficios_funcionais').insert({
                        'receita_id': receita_id,
                        'beneficio': str(beneficio)
                    }).execute()

            logger.info(f"Receita '{dados_receita['titulo']}' adicionada com sucesso")
            return True
        except Exception as e:
            logger.error(f"Erro ao adicionar receita: {e}")
            return False

    def buscar_receitas(self, termo: str = None) -> List[Dict]:
        """Busca receitas no banco de dados"""
        try:
            query = self.supabase.table('receitas')\
                .select('''
                    *,
                    dicas (dica),
                    beneficios_funcionais (beneficio)
                ''')

            if termo:
                termo = termo.lower()
                query = query.or_(f"titulo.ilike.%{termo}%,descricao.ilike.%{termo}%,ingredientes.ilike.%{termo}%,modo_preparo.ilike.%{termo}%")

            query = query.order('created_at', desc=True).limit(10)
            result = query.execute()

            receitas = []
            for row in result.data:
                # Processa dicas e benefícios
                dicas = [d['dica'] for d in row.pop('dicas', [])]
                beneficios = [b['beneficio'] for b in row.pop('beneficios_funcionais', [])]

                # Monta o dicionário da receita
                receita = {
                    **row,
                    'dicas': dicas,
                    'beneficios_funcionais': beneficios,
                    'informacoes_nutricionais': {
                        'calorias': row.pop('calorias', ''),
                        'proteinas': row.pop('proteinas', ''),
                        'carboidratos': row.pop('carboidratos', ''),
                        'gorduras': row.pop('gorduras', ''),
                        'fibras': row.pop('fibras', '')
                    }
                }
                receitas.append(receita)

            logger.info(f"Busca por '{termo}' retornou {len(receitas)} receitas")
            return receitas
        except Exception as e:
            logger.error(f"Erro ao buscar receitas: {e}")
            return []

    @st.cache_data(ttl=3600)  # Cache por 1 hora
    def buscar_receitas_cached(self, termo: str = None) -> List[Dict]:
        """Busca receitas no banco de dados com cache"""
        return self.buscar_receitas(termo)

    def exportar_receitas(self, formato: str = 'json') -> Union[str, Dict]:
        """Exporta todas as receitas em um formato específico"""
        try:
            receitas = self.buscar_receitas()
            
            if formato == 'json':
                return json.dumps(receitas, ensure_ascii=False, indent=2)
            elif formato == 'markdown':
                texto = "# Receitas da Chef Michelle\n\n"
                texto += f"Exportado em: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                
                for receita in receitas:
                    texto += f"## {receita['titulo']}\n\n"
                    if receita.get('descricao'):
                        texto += f"{receita['descricao']}\n\n"
                    texto += "### Ingredientes\n\n"
                    texto += f"{receita['ingredientes']}\n\n"
                    texto += "### Modo de Preparo\n\n"
                    texto += f"{receita['modo_preparo']}\n\n"
                    if receita['dicas']:
                        texto += "### Dicas\n\n"
                        for dica in receita['dicas']:
                            texto += f"- {dica}\n"
                        texto += "\n"
                    if receita['beneficios_funcionais']:
                        texto += "### Benefícios Funcionais\n\n"
                        for beneficio in receita['beneficios_funcionais']:
                            texto += f"- {beneficio}\n"
                        texto += "\n"
                    texto += "---\n\n"
                return texto
            else:
                raise ValueError(f"Formato '{formato}' não suportado")
        except Exception as e:
            logger.error(f"Erro ao exportar receitas: {e}")
            return "" if formato == 'markdown' else "{}"

    @st.cache_data(ttl=3600)  # Cache por 1 hora
    def exportar_receitas_cached(self, formato: str = 'json') -> Union[str, Dict]:
        """Exporta todas as receitas em um formato específico com cache"""
        return self.exportar_receitas(formato) 